{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Hybrid-genome-assembly-practice","text":"<p>For full documentation visit MSc Bioinformatics moodle.</p>"},{"location":"#context","title":"Context","text":"<p>Several patients have arrived at the hospital showing a common clinical presentation suggesting an infectious disease. Samples were collected and submitted to the laboratory and subjected to analyses for a complete panel of pathogens, which negative results for all the test. Given the urgency of the situation and the need of a clear diagnostic to implement a treatment to content the progress of infections, the laboratory isolated one strains and extracted the DNA to try to identify the pathogen through sequencing...</p> <p>The lab contacts the head of the genomic department and request the sequencing of the strain to try to identify the species through the taxonomic assignation of the sequences. In addition to the species, information about virulence traits and antibiotic resistance have been also requested to be inferred from the \u201cin silico\u201d analyses of the strain genome.</p> <p>To sequence the pathogen, a MinION device from Oxford Nanopore is available in your laboratory, although the team decided to obtain a second sequence using Illumina to contract with the Nanopore sequence and try to improve the quality of the genome. As your lab has not a Illumina sequencer, the DNA extraction is shipped to an external facility to be sequenced using Illumina requesting a \u201cgood quality\u201d in terms of coverage (depth). Now your boss has read that some crazy scientist have started to do something called... hybrid assembly. So she ask you to try this approach ...of course.</p> <p></p>"},{"location":"#intro","title":"Intro","text":"<p>Assemble a genome!</p> <p>Learn how to create and assess genome assemblies using the powerful combination of Nanopore and Illumina reads</p> <p>This tutorial explores how long and short read data can be combined to produce a high-quality \u2018finished\u2019 bacterial genome sequence. Termed \u2018hybrid assembly\u2019, we will use read data produced from two different sequencing platforms, Illumina (short read) and Oxford Nanopore Technologies (long read), to reconstruct a bacterial genome sequence.</p> <p>In this tutorial we will perform \u2018de novo assembly\u2019. De novo assembly is the process of assembling a genome from scratch using only the sequenced reads as input - no reference genome is used. This approach is common practise when working with microorganisms, and has seen increasing use for eukaryotes (including humans) in recent times.</p> <p>Long reads can be used together with short reads to produce a high-quality assembly. Nanopore long reads (commonly &gt;40,000 bases) can fully span repeats, and reveal how all the genome fragments should be arranged. Therefore, while long reads will provide the general structure of the genome, short reads will provide that high base-level accuracy needed to close a genome.</p> <p>Data: Nanopore reads, Illlumina reads</p> <p>Tools: <code>Canu</code>, <code>Pilon</code>, <code>Unicycler</code>, <code>Quast</code>, <code>Busco</code>, <code>BWA</code>, <code>Samtools</code>,<code>FastQC</code>, <code>Trimmomatic</code>,<code>Cutadapt</code>,<code>Nanoplot</code>,<code>Filtlong</code>,<code>Porechop</code></p>"},{"location":"#section-1-read-inspection-and-qc","title":"Section 1: Read inspection and QC","text":"<p>In this section we will import and perform quality control (QC) on our data. </p> <p>Today we will use 4 pieces of data - 2 short read sets, 1 long read set, and a reference genome (to compare our assembly with). </p> <p></p>"},{"location":"#getting-the-data","title":"Getting the data","text":"<p>For the illumina reads, the external organization has already uploaded the reads to the NCBI SRA database (Sequence Read Archive) which is the largest publicly available repository of high throughput sequencing data.</p> <p>To download the data we will use the <code>fasterq-dump</code> tool from the SRA-toolkit which should be already installed in your conda environment. We know that the accession ID of our samples is SRR10345480 and SRR9042863. </p> <p>Before we start typing and running commands, is important to generate a new directory where all the files are going to be saved and organized. In our case we are going to create a directory called <code>hybrid_assembly</code> and a subdirectory called <code>data</code> in this subdirectory is where we are going to save our reads. Do not move them at any moment</p> <pre><code>mkdir -p hybrid_assembly/data\ncd hybrid_assembly/data\nfasterq-dump {accesion_ID} #repeat for both accesion IDs\n</code></pre>"},{"location":"#read-inspection","title":"Read inspection","text":"<p>Often, it is prudent to first assess the quality of our read sets. For the short reads, we are concerned with base quality, sequence duplication, and presence of adapter sequences. For nanopore, we want to know about the length and quality distribution of reads, as these may both be highly variable. </p> <p><code>FastQC</code> creates summary reports for short read data. If we were on a different situation with multiple samples and therefore, multiple fastqs, we could then use a tool called <code>MultiQC</code> to combine these reports for easy viewing. </p> <p>For Nanopore data, <code>NanoPlot</code> is a great option. It creates plots which aim to summarise the length and quality distribution of long read sets. </p> <p>Depending on these summaries, we may choose to perform a QC step to remove any poor quality reads before proceeding. </p> <p>Run FastQC</p> <p>As said before, we will use <code>FastQC</code> to see the quality of our Illumina reads. Once again, remember Organization is key, therefore we are going to create a new directory where we are going to save all our Quality Control outputs <pre><code>#go to the main directory hybrid_assembly\n\nmkdir -p qc/illumina_raw\ncd qc/illumina_raw\n\nfastqc data/SRR*_1.fastq data/SRR*_2.fastq -o ./\n</code></pre></p> <p>FastQC produces two outputs - 'RawData', and 'html'. Typically, the html is for human viewing, and the RawData can be given to other programs, such as MultiQC.</p> <p>Let's see how the QC went on the Illumina Reads  </p> Question 1(click to reveal) What do you think about them? Do you think they have enough quality? Let's discuss, take your time to inspect the whole html  <p>Clean Illumina reads</p> <p>It seems that our samples have some unwanted short reads and the quality of some bases is not as good as it could be. There are plenty of programs such as <code>trimmomatic</code> or <code>cutadapt</code> that can be used to filter our Illumina reads.First we will get rid of the Illumina adapters, in this case we use Nextera adapters, using <code>Cutadapt</code>. Then we will filter to the get the best possible reads by quality and length using <code>Trimmomatic</code> <pre><code>#go to the main directory hybrid_assembly\nmkdir -p qc/trimmomatic\n\ncutadapt -a CTGTCTCTTATACACATCT -A AGATGTGTATAAGAGACAG -o qc/trimmomatic/out_illumina_1.fastq -p qc/trimmomatic/out_illumina_2.fastq data/SRR9042863_1.fastq data/SRR9042863_2.fastq\ntrimmomatic PE -threads 4 -phred33 qc/trimmomatic/out_illumina_1.fastq qc/trimmomatic/out_illumina_2.fastq qc/trimmomatic/illumina_trimmed_1.fastq qc/trimmomatic/illumina_unpair_1.fastq qc/trimmomatic/illumina_trimmed_2.fastq qc/trimmomatic/illumina_unpair_2.fastq SLIDINGWINDOW:20:20 MINLEN:250\n</code></pre></p> <p>We have generated two new fastqs called <code>illumina_trimmed_1.fastq</code> and <code>illumina_trimmed_1.fastq</code>.  From now on when we say Illumina reads, these are the ones that we are talking about. Now is time to see how this new fastqs differ from the others.</p> <pre><code>#go to the main directory hybrid_assembly\nmkdir -p qc/illumina_trimmed\n\nfastqc qc/trimmomatic/illumina_trimmed_1.fastq qc/trimmomatic/illumina_trimmed_2.fastq -o qc/illumina_trimmed\n</code></pre> <p> </p> <p> Look at the difference in number of reads between the raw and the trimmed fastqs.</p> <p>Run NanoPlot</p> <p>As you know the reads of Nanopore are much longer than the Illumina ones, although in some cases (such as 16S experiments) we can use FastQC to look at them, it is better to use a tool specifically designed for Nanopore, in this case we are going to use <code>Nanoplot</code></p> <pre><code>#go to the main directory hybrid_assembly\n\nmkdir -p qc/nanoplot_raw\ncd qc/nanoplot_raw\n\nNanoPlot -t 4 --fastq ../../data/SRR10*.fastq\n</code></pre> <p>Our median read length (7,365 pb) is quite good for Nanopore data,although some reads can be even longer, but the mean read quality is not that good (9.7), not so much time ago we would say that this quality is quite nice but the last generation of Nanopore flowcells produce much better reads, some of them at the same level as Illumina. Now as we did before with the Illumina reads, let's clean the Nanopore reads.</p> <p>Clean Nanopore reads</p> <p>For cleaning our <code>Nanopore Reads</code> we will be using <code>Porechop</code>and <code>Filtlong</code> which are both of the most standardized software used for that. <code>Porechop</code>is the equivalent of <code>Cutadapt</code> in Illumina and <code>Filtlong</code> is the equivalent of <code>Trimmomatic</code>. Why do we need different programs to do that? Well, different technologies need different approaches, although some of the most popular software right now can support all <code>PacBio</code>, <code>Illumina</code>and <code>Nanopore</code>reads.</p> <pre><code>#go to the main directory hybrid_assembly\n\nmkdir -p qc/nanoplot_trimmed\ncd qc/nanoplot_trimmed\n\nporechop -i ../../data/SRR10*.fastq -o ./nanopore_adapter_clean.fastq\nfiltlong --min_length 1000 --keep_percent 90 --mean_q_weight 9 nanopore_adapter_clean.fastq &gt; nanopore_filtered.fastq\n</code></pre> <p> As we did with the Illumina reads, from now on when we say nanopore reads we will be referring to <code>nanopore_filtered.fastq</code></p> <p>assign taxonomy of the pathogen</p> <p>Now that we have our reads clean, it is always interesting to know what are we looking for. Doing an assembly without knowing what are we facing could be terrible. For example, imagine that you have assembled a genome with 6 closed chromosomes, first of all, congratulations because that is not easy, but then you assign somehow the taxonomy of that organism and... WOW is a Ficus! \ud83c\udf43 \ud83d\udc4f\ud83d\udc4f, but you rapidly realize that Ficus is 2n=26 and something has gone wrong.</p> <p>There is plenty of ways to assign taxonomy when doing an assembly, for example one of the most used programs to assign taxonomy to illumina reads is <code>Kraken2</code>, another one used with Nanopore reads could be <code>Emu</code>. But these programs require powerful machines, and let's be honest, your gaming laptop MSI i9 with 12 Cores and 32 GB of Ram is not as powerful as the clusters that are typically used for this jobs (we are talking about &gt;40 Cores &gt;100GB ram).</p> <p>To make things easy and rapid, we are going to do a trick. Taking advantage of the length of the nanopore reads, we will select the first read of the <code>fastq</code> file, or the second, it doesn't matter whilst is long enough, and they all should be after the QC that we have done, then we are going to blast it!</p> <p><pre><code>head qc/nanopore_trimmed/nanopore_filtered.fastq #you can also open the file and select the first read\n</code></pre> Now that you have copied the first read, go to Blastn and submit a job using the blastn option. Wow is a Vibrio parahaemolyticus, thanks god is not that ficus again! Go to the NCBI and download in <code>Fasta</code> format the GCA_009649015.1 genome in a unique file. Once you have download it, change the name of the fasta to <code>VP_reference_genome.fasta</code> and save it in the data directory.</p>"},{"location":"#section-2-nanopore-draft-assembly","title":"Section 2: Nanopore draft assembly","text":""},{"location":"#a-baseline-for-high-quality-assemblies","title":"A baseline for \"high-quality\" assemblies","text":"<p>To begin, we will identify what a high-quality assembly looks like.</p> <p>When running assembly tools, we want to check the quality of assemblies we produce. It is paramount that genome assemblies are high-quality for them to be useful.</p> <p>To get a baseline for what is considered a \"high-quality\" assembly, we will first run a common assembly QC tool - <code>Busco</code> - on a published genome similar to the organism we are working with today.</p> <p>Busco</p> <p><code>Busco</code> analysis uses the presence, absence, or fragmentation of key genes in an assembly to determine its quality.</p> <p><code>Busco</code> genes are specifically selected for each taxonomic clade, and represent a group of genes that each organism in the clade is expected to possess. At higher clades, 'housekeeping genes' are the only members, while at more refined taxa such as order or family, lineage-specific genes can also be used.</p> <p>We expect the reference genome to have all of these genes. When running <code>Busco</code>, we expect it to find most (if not all) of these in the assembly.</p> <p>Let's create a new directory called <code>assembly_qc</code>. We want to create this directory outside from the <code>qc</code> directory we have been working on.</p> <p>remember the directory structure we are using</p> <p>hybrid_assembly[data(fastqs), qc(illumina_raw, nanopore_raw, illumina_trimed, fastp), assembly_qc]</p> <p><pre><code>#go to the main directory hybrid_assembly\nmkdir -p assembly_qc\ncd assembly_qc\nbusco -i ../../data/VP_reference_genome.fasta -l vibrionales -o busco_reference --augustus --mode genome \n</code></pre> After the program has run, look at the \u2018short summary\u2019 output. It may look something like this:</p> <p></p> <p>It seems that BUSCO could find almost all expected genes in the reference genome assembly. By looking at the results, we see that we have 1443 / 1444 Complete BUSCOs, one being complete and duplicates, and another one missing.</p> <p>This will form the baseline for the BUSCO QC results expected of a high-quality genome assembly.</p> <p>From here, we will use our input DNA sequence data to assemble the genome of the sequenced organism, and will compare the QC results to that of the published <code>VP_reference_genome.fasta</code> assembly.</p>"},{"location":"#draft-assembly-with-canu-nanopore-reads","title":"Draft assembly with Canu + Nanopore reads","text":"<p>Our first assembly will use the long-read data to create a draft genome, then the short-read data to \"polish\" (improve) the draft into a better assembly.</p> <p>We will start by using a long-read assembly tool called <code>Canu</code> to create an assembly using the Nanopore long-read data.</p> <p>Once again we need to create an specific directory for that, let's move again to the general <code>hibrid_assembly</code> directory we will create a directory called <code>assemblies</code> where we will compute all the assemblies in this practice</p> <pre><code>#go to the main directory hybrid_assembly\nmkdir -p assemblies/canu\ncanu -p canu -d assemblies/canu -nanopore qc/nanopore_trimmed/nanopore_filtered.fastq --genomeSize=5.1m\n</code></pre> <p>We need to compare this assembly with our reference genome. For that we are going to use <code>Busco</code> again and `Quast</p> <pre><code>#go to the main directory hybrid_assembly\n\nmkdir -p assembly_qc/canu_nanopore\ncd assembly_qc/canu_nanopore\n\nbusco -i ../../assemblies/canu/canu.contigs.fasta -l vibrionales -o busco --augustus --mode genome --cpu 4\n</code></pre> <p></p> Question 2(click to reveal) As you can see we do not get the same output as the reference, Why do you think this is happening?  <p>Quast</p> <p>Aside from <code>Busco</code>, we can use another method to perform assembly QC. In this case <code>Quast</code>allows us to compare two assemblies to determine their similarity.</p> <p>We know that Bacteria can differ a lot between individuals of the same species, nevertheless they should have the same number of chromosomes with similar lengths. What we are going to do know is compare both <code>VP_reference_genome.fasta</code>and this new draft assembly based on Nanopore.</p> <p>You know what is coming next, Yes! another directory </p> <p><pre><code>#in the same assembly_qc/canu_nanopore directory as before\n\nquast ../../assemblies/canu/canu.contigs.fasta -r ../../data/VP_reference_genome.fasta -o quast\n</code></pre> The output of <code>Quast</code> should be a directory with a set of files, we are interested in the <code>report.html</code> file Now you should be looking at something like this:</p> <p></p> <p>what are we looking for? Well there is plenty of information here but you should take a closer look to: * Genome fraction * Number of contigs * Number of misassemblies * Number of mismatches per 100Kbp * Number of indels per 100Kbp * Total length * Largest contig * L50 * N50 * LGA50 * NGA50</p> Question 3(click to reveal) Which is the differnce between L50 and LGA50? What about N50 and NGA50?  Question 4(click to reveal) What do you think about the nanopore assembly? is it good enough for you?"},{"location":"#assembly-polishing-with-pilon","title":"Assembly polishing with Pilon","text":"<p>We should be able improve our assembly with the Illumina reads available and correct some of these errors.</p> <p>This process involves two steps. We will first align the Illumina reads to our draft assembly, then supply the mapping information to Pilon, which will use this alignment information to error-correct our assembly.</p> <p>Illumina reads have much higher per-base accuracy than Nanopore reads. We will map the Illumina reads to our draft assembly using a short-read aligner called BWA-MEM. Then we can give Pilon this alignment file to polish our draft assembly.</p> <p> This is maybe one of the most complex steps that we are going to compute so be careful and don't get lost</p> <p>Map Illumina reads to Nanopore draft assembly</p> <p>To map the Illumina reads to the Nanopore assembly, first we need to index our assembly, for that we will be using <code>Bwa</code> and <code>Samtools</code></p> <p>Indexing is an essential step in many bioinformatics applications, as it can greatly reduce the computational time and resources required for sequence alignment. It allows the alignment algorithm to quickly locate the query sequences in the reference genome, without having to search the entire genome for matches <pre><code>#go to the main directory hybrid_assembly\n\nmkdir -p assemblies/error_corrected_canu\ncd assemblies/error_corrected_canu\nmkdir index\n\nbwa index -p index/index ../canu/canu.contigs.fasta\nbwa mem index/index ../../qc/trimmomatic/illumina_trimmed_1.fastq  ../../qc/trimmomatic/illumina_trimmed_2.fastq | samtools sort -o illumina_sorted.bam\nsamtools index -bc illumina_sorted.bam\n</code></pre></p> <p>We should get a BAM file as an output. This is tabular data recording information about how reads were aligned to the draft assembly. Now we can use that the <code>illumina_sorted.bam</code>to run <code>Pilon</code>.</p> <p><pre><code>pilon --genome ../canu/canu.contigs.fasta --bam illumina_sorted.bam --outdir pilon -Xmx12G\n</code></pre> Once <code>Pilon</code> has ended we should find a unique Fasta file in the <code>pilon</code> directory</p> <p>Assembly QC</p> <p>Now that we have run Pilon, thanks to the help of the illumina reads we should get a much better assembly than before. But we cannot call ourselves scientist only with assumptions we need facts. Therefore, let's run Busco and Quast...yes, again </p> <pre><code>#go to the main directory hybrid_assembly\n\nmkdir -p assembly_qc/canu_nanopore_illumina\ncd assembly_qc/canu_nanopore_illumina\n\nbusco -i ../../assemblies/error_corrected_canu/pilon/pilon.fasta -l vibrionales -o busco --augustus --mode genome --cpu 4\nquast ../../assemblies/error_corrected_canu/pilon/pilon.fasta -r ../../data/VP_reference_genome.fasta -o quast\n</code></pre> <p> </p> Question 5(click to reveal) What do you think about the results? Do you see any improvements?"},{"location":"#section-3-hybrid-assembly-unicycler","title":"Section 3: Hybrid assembly - Unicycler","text":"<p>In this section, we will use a purpose-built tool called <code>Unicycler</code> to perform hybrid assembly.</p> <p><code>Unicycler</code> uses our <code>Nanopore</code> and <code>Illumina</code> read sets together as input, and returns an assembly. Once we have created the assembly,  we will assess its quality using <code>Quast</code> and <code>Busco</code> and compare with our previous polished assembly.</p> <p><code>Unicycler</code> performs assembly in the opposite manner to our approach. <code>Illumina</code> reads are used to create an assembly graph, then <code>Nanopore</code> reads  are used to disentangle problems in the graph. The Nanopore reads serve to bridge Illumina contigs, and to reveal how the contigs are arranged  sequentially in the genome. </p> <p>Run Unicycler</p> <p><pre><code>#go to the main directory hybrid_assembly\n\nunicycler -1 qc/trimmomatic/illumina_trimmed_1.fastq -2 qc/trimmomatic/illumina_trimmed_2.fastq -l qc/nanopore_trimmed/nanopore_filtered.fastq -o assemblies/unicycler -t 4\n</code></pre> Once it has ended, if you go to the <code>assemblies/unicycler</code> directory, you should find the assembly file called <code>assembly.fasta</code></p> <p>Assembly QC</p> <p>As we did with the <code>Canu</code> and <code>Pilon</code> assembly, we need to perform a Quality Control (QC) to our newly assembled genome.</p> <pre><code>#go to the main directory hybrid_assembly\n\nmkdir -p assembly_qc/unicycler_alone\ncd assembly_qc/unicycler_alone\n\nbusco -i ../../assemblies/unicycler/assembly.fasta -l vibrionales -o busco --augustus --mode genome\nquast ../../assemblies/unicycler/assembly.fasta -r ../../data/VP_reference_genome.fasta -o quast\n</code></pre> <p>these are the results that we have obtained from Unicycler:</p> <p> </p> Question 6(click to reveal) Which are the differnces between the pilon assembly and this one?  Question 7(click to reveal) What do you think about the hybrid assembly? is it good enough for you?"},{"location":"#section-4-nobody-expects-this-combo-unicycler-x-canu","title":"Section 4: Nobody expects this combo - Unicycler x Canu","text":"<p>As you have read in the section 4 title, now we are going to do a Unicycler run based on our Canu run, and yes! this is possible. For that we are going to use the <code>Unicycler</code> option <code>--existing_long_read_assembly</code>. Remember when we mapped the illumina reads to the Canu draft assembly so<code>Pilon</code> could improve our the assembly? Well let's say this is something similar. This time Unicycler instead of building everything without a base, it will have de Canu_improved_assembly as baseline, and you will see that this time we will have a better result.</p> <pre><code>#go to the main directory hybrid_assembly\n\nmkdir -p assemblies/unicycler_canu\ncd assemblies/unicycler_canu\n\nunicycler -1 ../../qc/trimmomatic/illumina_trimmed_1.fastq -2 ../../qc/trimmomatic/illumina_trimmed_2.fastq -l ../../qc/nanopore_trimmed/nanopore_filtered.fastq -o ./ -t 4 --existing_long_read_assembly ../error_corrected_canu/pilon/pilon.fasta\n</code></pre> <p>I can't believe it! We are at the end, just compute the QC of that assembly and let's go back home </p> <p><pre><code>#go to the main directory hybrid_assembly\n\nmkdir -p assembly_qc/unicycler_canu\ncd assembly_qc/unicycler_canu\n\nbusco -i ../../assemblies/unicycler_canu/assembly.fasta -l vibrionales -o busco --augustus --mode genome --cpu 4\nquast ../../assemblies/unicycler_canu/assembly.fasta -r ../../data/VP_reference_genome.fasta -o quast\n</code></pre> </p>"},{"location":"Laboratory_practice/","title":"Rapid Sequencing Kit","text":""},{"location":"Laboratory_practice/#context","title":"Context","text":"<p>Several patients have arrived at the hospital presenting a clear illness pattern. You have tried to determine which pathogen is, but all your tests have failed, number of cases don't stop and more and more patients arrive at the hospital, the time is running and you need a solution.</p> <p>You have shared this problems with your boss and, rapidly, you both arrive into a conclusion, sequencing the pathogen. But She wants you to sequence the pathogen using both sequencing techonologies, Illumina and Nanopore. Now is time for you to realise how to do this task, as there is no other bioinformatitian in the hospital. The first thing that we are going to do is consider that our genome is 5.1Mb, but the next questions are tougher, Do we have enough DNA? Which Illumina kit are you going to use if we have an Illumina MiSeq? Can I sequence more than 1 samples in the same Nanopore Flowcell?</p> <p>Maybe this job is not as good payed as you thought </p> <p></p>"},{"location":"Laboratory_practice/#a-bit-about-nanopore","title":"A bit about Nanopore","text":"<p>Nanopore sequencing is a third-generation sequencing technology that allows us to determine the nucleotide sequences in a sample.</p> <p>The sample is placed in a flow cell, where it interacts with nanopores located in a sensor array, and an electric current is applied. As each DNA or RNA fragment passes through a nanopore, it causes changes in the ion flow, which alter the current. These changes are linked to the passage of specific nucleotide bases through the nanopores, in a process called basecalling, which identifies the sequence in real time. A key advantage of nanopore sequencing is that, unlike other technologies, it can handle very long fragments of DNA or RNA without size limitations.</p> <p>Given that the studied genome is 5.1 Mb, if you want to sequence your sample using an Illumina MiSeq System with a coverage of 60X, how many reads would you obtain?</p>"},{"location":"Laboratory_practice/#output-discussion","title":"Output Discussion","text":"<p>Our boss has told us that he wants an Illumina sequencing with a coverage of X60 and paired-end reads. We have a Miseq in our lab, but as you know there are plenty of Illumina kits to sequence in that machine, so maybe you should first think about the output that you know you are going to get with the specifications that your boss told you. Thanks god your old teacher gave you some lessons about how to calculate this during you master.</p> Question 1(click to reveal) Given that the studied genome is 5.1 Mb, if you want to sequence your sample using an Illumina MiSeq System with a coverage of 60X, how many reads would you obtain?  <p>Now go to the Illumina page and make sure that your results are correct.</p> Question 2(click to reveal) Which MiSeq Illumina kit should we use if we only have 1 sample? Which one would you use if there were more samples?  <p>In the case of Nanopore we have two different sequencers, the Cancer team is working right now with the PromenthION and we could use it, but in our laboratory we have the MinION and maybe there's no need to bother them. Take into consideration that the Flow Cells for these sequencers are different: the MinION/GridION Flow Cell outputs a maximum of 50 Gb and the PromethION Flow Cell a maximum of 290 Gb.</p> Question 3(click to reveal) Knowing this, which sequencer would you use to sequence your sample?  Question 4(click to reveal) If we use the whole Flow Cell, which cover should we get?   Question 5(click to reveal) With the research that we have already done we know that we only need a coverage of X20 with the nanopore reads. Obviously your output is going to be much more bigger, How would you handle it?"},{"location":"Laboratory_practice/#section-1-qubit-dsdna-hs-assay-kit","title":"Section 1: Qubit dsDNA HS Assay Kit","text":"<p>The Qubit fluorometer is a device capable of quantifying the amount of DNA, RNA, or proteins present in a sample.</p> <p>To achieve so, a portion of the sample is mixed with Working Solution, a mixture of buffer and a dye that binds to the target molecule. This dye, when excited in the fluorometer, emits a fluorescent signal. Using standards, Qubit generates a calibration curve that it uses to determine the concentration based on the intensity of the signal, thereby calculating the amount of DNA, RNA, or protein present in the sample.</p> <p>(The amount of sample used cannot be recovered, so efforts are made to use as little as possible for concentration measurements).</p> <ol> <li>Prepare the Qubit working solution by diluting the Qubit dsDNA HS Reagent 1:200 in Qubit dsDNA HS Buffer. To do so, add 199(n+1) \u00b5l of Buffer and 1(n+1) \u00b5l of Reagent in a Falcon tube.</li> <li>To prepare the standards, add 10 \u00b5L of each Qubit standard to the appropriate tube. And mix it with 190 \u00b5l of working solution.</li> <li>To prepare the samples, add 1-20 \u00b5L of each sample to the appropriate tube. Add the Qubit working solution to each tube such that the final volume is 200 \u00b5L. Recommended: Use 2 \u00b5l of sample and fill it up with 198 \u00b5l of working solution.</li> <li>Vigorously vortex for 3\u20135 seconds. Be careful not to create bubbles.</li> <li>Allow all tubes to incubate at room temperature for 2 minutes, then proceed to read standards and samples in a Qubit fluorometer.</li> </ol> Question 6(click to reveal) Taking into considereation that we have to sequence in two different sequencers with different input specifications, do you think that we have enough DNA to satisfy the minimum input of both sequencers?  Question 7(click to reveal) What would you do if you have enough DNA but the amount of microliters that you need to add is more than the maximum expected?"},{"location":"Laboratory_practice/#section2-library-preparation","title":"Section2: Library preparation","text":"<p>Among the various kits offered by Oxford Nanopore Technologies (ONT), the Rapid Barcoding Kit has as the fastest and simplest protocol for genomic DNA. Unlike other kits, this one includes an initial fragmentation step. While it may seem counterintuitive, research has shown that this fragmentation actually facilitates longer reads, and ONT suggests that some fragments may be so long that they can become \"lost\" during library preparation and fragmentation may solve that situation.</p> <p>After fragmentation, as with the other kits, an adapter must be added to the sequences to enable their binding to the nanopore. Additionally, the sequencing buffer and library beads are included, which provide density to the sample and enhance contact with the nanopores.</p> <p>At the same time, the flow cell must also be prepared using the flow cell priming mix, which helps, among other things, to maintain an appropriate pH, and stabilize the sequences.</p> <ol> <li>Transfer 100-150 ng genomic DNA into a 1.5 ml Eppendorf DNA LoBind tube.</li> <li>Adjust the volume to 10 \u00b5l with nuclease-free w\u00e1ter.</li> <li>In a 0.2ml thin-walled PCR tube, mix 10 \u03bcl of template DNA and 1 \u03bcl of Fragmentation Mix (FRA).Mix gently.</li> <li>Incubate the tube at 30\u00baC for 2 minutes and then at 80\u00baC for 2 minutes. Briefly put the tube on ice to cool it down.</li> <li>Add 1\u03bcl of diluted Rapid Adapter (RA) to the tagmented DNA. Mix gently.</li> <li>Incubate the reaction for 5 minutes at room temperatura.</li> </ol>"},{"location":"Laboratory_practice/#section3-priming-and-loading-the-flow-cell","title":"Section3: Priming and loading the Flow Cell","text":"<ol> <li>To prepare the flow cell priming mix add 1,170 \u00b5l of Flow Cell Flush (FCF) and 30 \u00b5l of Flow Cell Tether (FCT) into a 1.5 ml Eppendorf DNA LoBind tube. Mix by pipetting.</li> <li>Slide the flow cell priming port cover clockwise to open the priming port. </li> <li>After opening the priming port, check for a small air bubble under the cover. Draw back a small volume to remove any bubles. </li> <li>Load 800 \u00b5l of the priming mix into the flow cell via the priming port, avoiding the introduction of air bubbles. Wait for five minutes. </li> <li>Thoroughly mix the contents of the Library Beads (LIB) by pipetting.</li> <li>In a new 1.5 ml Eppendorf DNA LoBind tube, prepare the library for loading as follows:</li> <li>Sequencing Buffer (SB) 37.5 \u00b5l</li> <li>Library Beads (LIB) mixed immediately before 25.5 \u00b5l</li> <li>DNA library 12 \u00b5l</li> <li>To complete the flow cell priming, gently lift the SpotON sample port cover to make the SpotON sample port accessible.</li> <li>Load 200 \u00b5l of the priming mix into the flow cell priming port (not the SpotON sample port), avoiding the introduction of air bubbles.  </li> <li>Mix the prepared library gently by pipetting up and down just prior to loading.</li> <li>Add 75 \u03bcl of the prepared library to the flow cell via the SpotON sample port in a dropwise fashion. Ensure each drop flows into the port before adding the next. </li> <li>Close the SpotOn port and the priming port.</li> </ol>"}]}